<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Infrared4Arduino: Infrared4Arduino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Infrared4Arduino
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Infrared4Arduino </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is yet another infrared library for the Arduino. (Although its name does not start with YA...)</p>
<p>It is a major rewrite of <a href="http://tech.cyborg5.com/irlib/">Chris Young's IRLib</a>, (<a href="https://github.com/cyborg5/IRLib">GitHub repo</a>), which itself is a major rewrite of a library called IRremote, published by Ken Shirriff in <a href="http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html">his blog</a>, now maintained <a href="https://github.com/z3t0/Arduino-IRremote">on GitHub</a>. It uses Michael Dreher's <a class="el" href="classIrWidget.html" title="Base class for classes based upon ICP pins capture. ">IrWidget</a> <a href="http://www.mikrocontroller.net/articles/High-Speed_capture_mit_ATmega_Timer">(article in German)</a>, see also <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=111876#111876">this forum contribution</a>.</p>
<p>The classes <code><a class="el" href="classIrWidget.html" title="Base class for classes based upon ICP pins capture. ">IrWidget</a></code> and <code><a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget. ">IrWidgetAggregating</a></code> are based on Michael's code. The classes <code><a class="el" href="classIrReceiverSampler.html" title="This receiving class samples the input pin every 50 microseconds using a timer interrupt. ">IrReceiverSampler</a></code> and <code><a class="el" href="classIrSenderPwm.html" title="Sending function using timer PWM. ">IrSenderPwm</a></code>, and in particular the file <code>IRremoteInt.h</code>, are adapted from Kevin's and Chris' work. The remaining files are almost completely written from scratch, although the influence of Kevin and Chris is gratefully acknowledged.</p>
<p>This work is a low-level library (like IRremote and IRLib) that can be used in other projects, like <a href="https://github.com/bengtmartensson/AGirs">AGirs</a>, which is an high-level program taking commands interactively from a user or a program through a bi-directional <code>Stream</code>. The goal has been to provide a sound, object oriented basis for the fundamental basis, not to provide maximal functionality, the maximal number of protocols supported, or the most complete support of different hardware. A clean design and high readability, without being "too" inefficient, has been the highest priority. Dynamic memory allocation with <code>new</code> and <code>delete</code> is used extensively. The user who is afraid of this can create his required objects at the start of the run, and keep them. Most classes are immutable. The classes are <code>const</code>-correct.</p>
<h1>API</h1>
<h2>Types</h2>
<p>There are some project specific data typedefs in <code><a class="el" href="InfraredTypes_8h.html" title="This file defines some general data types that are used in the library. ">InfraredTypes.h</a></code>. For durations in microseconds, the data type <code>microseconds_t</code> is to be used. If desired/necessary, this can be either <code>uint16_t</code> or <code>uint32_t</code>. For durations in milliseconds, use the type <code>millisecons_t</code>. Likewise, use <code>frequency_t</code> for modulation frequency in Hz (<em>not</em> kHz as in the IRremote/IRLib).</p>
<p>For "sizes", <code>size_t</code>, the standard C type, is used.</p>
<p>Implementation dependent types like <code>int</code> are used if and <em>only if</em> it is OK for the compiler to select any implementation allowed by the C++ language.</p>
<p><code>unsigned int</code> is used for quantities that can "impossibly" be larger than 65535.</p>
<h2>IrSequences and IrSignals</h2>
<p>An <code><a class="el" href="classIrSequence.html" title="This class consists of a vector of durations. ">IrSequence</a></code> is a vector of durations, i.e. sequence of interleaving gaps and spaces. It does not contain the modulation frequence. As opposed to IRremote and IRLib, our sequences always start with a space and end with a gap. It is claimed to be a more relevant representation than the one of IRremote and IRLib.</p>
<p>An <code><a class="el" href="classIrSignal.html" title="This class models an IR signal with intro-, repeat-, and ending sequences. ">IrSignal</a></code> consists of a modulation frequency and three <code><a class="el" href="classIrSequence.html" title="This class consists of a vector of durations. ">IrSequence</a></code>s: intro-, repeat-, and ending sequence. All of these, but not all, can be empty. If repeat is empty, intro has to be non-empty and ending empty. The intro sequence is always sent first, then comes a zero or more repeat sequences, and finally the ending sequence. To send a signal <em>n</em> &gt; 0 times shall mean the following: If the intro is non-empty, send intro, <em>n</em> - 1 repeats, and then the ending. If the intro is empty, send <em>n</em> repeats, and then then ending.</p>
<h2>Class construction</h2>
<p>For some receiving and transmitting classes, multiple instantiations are not sensible, for other it may be. In this library, the classes that should only be instantiated once are implemented as singleton classes, i.e. with no public constructor, but instead a static "factory" method (<code>newThing()</code>) that delivers a pointer to a newly constructed instance of <code>Thing</code>, provided that <code>Thing</code> has not been instantiated before. The classes, where multiple instances is sensible, come with public constructors. (However, the user still has to take responsibility for avoiding pin- and timer-conflicts.)</p>
<h2>Hardware configuration</h2>
<p>For hardware support, the file <code>IRremoteInt.h</code> from the IRremote project is used. This means that all hardware that project supports is also supported here (for <code><a class="el" href="classIrReceiverSampler.html" title="This receiving class samples the input pin every 50 microseconds using a timer interrupt. ">IrReceiverSampler</a></code> and <code><a class="el" href="classIrSenderPwm.html" title="Sending function using timer PWM. ">IrSenderPwm</a></code>). (Actually, a small fix, borrowed from IRLib, was used to support Arduinos with ATMega32U4 (Leonardo, Micro).) However, <a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget. ">IrWidgetAggregating</a> is currently supported on the boards Uno/Nano (ATmega328P), Leonardo/Micro (ATmega32U4), and Mega2560 (ATmega2560).</p>
<p>Several of the sending and receiving classes take a GPIO pin as argument to the constructor. However, the sending pin of <code><a class="el" href="classIrSenderPwm.html" title="Sending function using timer PWM. ">IrSenderPwm</a></code> and the capture pin of <code><a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget. ">IrWidgetAggregating</a></code> are not configurable, but (due to hardware limitations) have to be taken from the following table: </p><pre class="fragment">                          Sender Pin      Capture Pin
Uno/Nano (ATmega328P)          3             8
Leonardo/Micro (ATmega32U4)    9             4
Mega2560 (ATmega2560)          9            49
</pre><h2>Timeouts</h2>
<p>All the receiving classes adhere to the following conventions: When initialized, it waits up to the time <code>beginningTimeout</code> for the first on-period. If not received within that period, it returns with a timeout. Otherwise, is starts collecting data. It will collect data until one of the following occurs:</p><ul>
<li>A silence of length <code>endingTimeout</code> has been detected. This is the normal ending. The detected last gap is returned with the data.</li>
<li>The buffer gets full. Reception stops.</li>
</ul>
<h2>User parameters</h2>
<p>As opposed to other infrared libraries, there are no user changeable parameters as CPP symbols. However, the timer configuration is compiled in, depending on the CPP processors given to the compiler, see the file <code>IRremoteInt.h</code>.</p>
<h2>Files</h2>
<p>As opposed to the predecessor projects, this project has a header (<code>*.h</code>) file and an implementation file (<code>*.cpp</code>, sometimes missing) for each public class.</p>
<h2>Error handling</h2>
<p>Simple answer: there is none. If a function is sent erroneous data, it just silently ignores the request, or does something else instead. This (unfortunately) seems to be the standard procedure in Arduino programming.</p>
<p>I am used to exception based error handling, for some reason this is not used by the Arduino community.</p>
<p>Constructive suggestions are welcome.</p>
<h2>Protocols</h2>
<p>Comparing with the predecessor works, this project may look meager, currently supporting only two protocols (NEC1 and RC5). It is <a href="https://github.com/bengtmartensson/IrpTransmogrifier">planned</a> to generate the corresponding C++ code automatically from the IRP notation. (For this reason, contributed implementations of more protocols are not solicited.)</p>
<h2>Sending non-modulated signals.</h2>
<p>RF signals (433 MHz and other carrier frequencies) do not use the IR typical modulation. Also there are a few IR protocols (like <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=14186&amp;start=40">Revox, Barco, Archer</a>) not using modulation. These signals can be sent by the class <code><a class="el" href="classIrSenderNonMod.html" title="IrSender implementation without modulation. ">IrSenderNonMod</a></code>, after connecting suitable hardware capable of sending non-modulated (IR- <em>or</em> RF-) signals to the GPIO pin given as argument to the constructor.</p>
<h2>Dependencies</h2>
<p>This library does not depend on any other libraries; only the standard Arduino environment.</p>
<h2>Questions and answers</h2>
<ul>
<li>What is the difference between the <code>IrReceiver*</code> and the <code>IrWidget*</code> classes?</li>
</ul>
<p>They are intended for two different use cases, <a href="http://www.harctoolbox.org/Glossary.html#ReceivingIrSignals">receiving</a> and <a href="http://www.harctoolbox.org/Glossary.html#Capturing">capturing</a>. Differently put, "receive" uses a demodulating receiver (TSOPxxx, etc.), "capture" a non-demodulating decoder (TSMPxxx, OPLxxx QSExxx, etc.). Note that this terminology is not universally accepted (yet!).</p>
<h1>Coding style</h1>
<p>My goal is to write excellent code, even though I do not always succeed :-). "Everything as simple as possible, but not simpler." Cleanliness, logical structure, readability and maintainability are the most important requirements. Efficiency (runtime and/or space) is also important, although it normally comes on second place. <a href="https://www.arduino.cc/en/Reference/APIStyleGuide">The Arduino Style Guide</a> has different goals (essentially optimizing for novice programmers, "Some of these run counter to professional programming practice"). It is therefore not given priority in this project.</p>
<h1>Documentation</h1>
<p>The main documentation for the classes is found in the source files themselves. It can be extracted to a browse-able documentation using the program <a href="http://www.doxygen.org">Doxygen</a>. After installing the program, fire up the program in the source directory. It will generate documentation in a subdirectory <code>html</code>. To browse, open <code>html/index.html</code> in a browser.</p>
<p>The documentation is written for the <em>user</em> of the library, not the developer. For this reason, the file <code>Arduino.h</code> has been deliberately excluded from the documentation, to keep it centered on the main issues for the programming on the target system.</p>
<h1>Multi platform coding</h1>
<p>For someone used to, e.g., Netbeans or Eclipse, the Arduino IDE feels "somewhat" primitive and limited. In particular, it does not support debugging. Mainly for this reason, the code in the present library is designed to compile, and at least to some extent, run in a normal C++ environment on the host compiler. For this, some code modifications, in particular, a customized <code>Arduino.h</code> was needed. If the preprocessor symbol <code>ARDUINO</code> is defined, just includes the standard Arduino <code>Arduino.h</code> is included, otherwise (i.e. for compiling for the host), some more-or-less dummy stuff are defined, allowing compiling for, and execution/debugging on the host.</p>
<p>This way, certain types of problems can be solved much faster. The drawback is that the code is "polluted" with ugly <code>#ifdef ARDUINO</code> statements, which decreases readability and makes maintenance harder.</p>
<p>The subdirectory <code>tests</code> contains test(s) that run on the host. The supplied <code>Makefile</code> is intended for compiling for the host as target. It creates a library in the standard sense (<code>*.a</code>), and can be used to build and run tests in subdirectory <code>tests</code>.</p>
<p>With the provided <code>Doxyfile</code>, Doxygen will document only the (strict) Arduino parts, not the "portable C++".</p>
<h1>License</h1>
<p>The entire work is licensed under the GPL2 "or later" license. Chris' as well as Ken's code is licensed under the LGPL 2.1-license. Michael's code carries the GPL2-license, although he is <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=112586#112586">willing to agree to "or later versions"</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Sep 11 2017 11:29:23 for Infrared4Arduino by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
