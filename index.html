<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Infrared4Arduino: Infrared4Arduino</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Infrared4Arduino
   &#160;<span id="projectnumber">1.2.2</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Infrared4Arduino </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a>Infrared4Arduino is an object-oriented infrared library for the Arduino.</p>
<h1>NEWS</h1>
<p><b>Version 1.2.0</b> constitutes a rather extensive refactoring, in particular regarding memory allocation. It now uses some of the features of "modern C++" (restricted to C++-11 for Arduino compatibility) (#16 and #17), like move semantics. For the API user, this means that the duration data used to call the constructors of <a class="el" href="classIrSequence.html" title="This class consists of a vector of durations.">IrSequence</a> and <a class="el" href="classIrSignal.html" title="This class models an IR signal with intro-, repeat-, and ending sequences.">IrSignal</a> are to be allocated using <code>new</code>, and are "moved" into the constructed objects. Also, MicroGirs has been removed. (The user should use <a href="https://github.com/bengtmartensson/AGirs">AGirs</a> instead.)</p>
<h1>Introduction</h1>
<p>The library was (with some exceptions detailed below) written from scratch by myself. It uses Michael Dreher's <a class="el" href="classIrWidget.html" title="Base class for classes based upon ICP pins capture.">IrWidget</a> <a href="http://www.mikrocontroller.net/articles/High-Speed_capture_mit_ATmega_Timer">(article in German)</a>, see also <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=111876#111876">this forum contribution</a>.</p>
<p>The main inspiration for the present work was the well-known library called IRremote, published by Ken Shirriff in <a href="http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html">his blog</a>, now <a href="https://github.com/z3t0/Arduino-IRremote">hosted on GitHub</a>. <a href="http://tech.cyborg5.com/irlib/">Chris Young's IRLib</a>, (<a href="https://github.com/cyborg5/IRLib">GitHub repo</a>), should also be mentioned as a source of inspiration, but not of code. The SAMD21 support (Arduino Zero and others) is based on issues in the IRremote repository, and in particular <a href="https://github.com/z3t0/Arduino-IRremote/pull/437">this pull request</a>. I am also indebted to <a href="https://forum.arduino.cc/index.php?topic=346731.0">this thread in the Arduino forum</a>. The ATMega4809 support (Arduino WiFi Rev 2 and Arduino Nano Every) is based upon <a href="https://github.com/z3t0/Arduino-IRremote/pull/657">this PR</a>. The Arduino <a class="el" href="classDue.html">Due</a> support is basically taken from <a href="https://github.com/enternoescape/Arduino-IRremote-Due">this project</a>, which is licensed under the LGPL 2.1 license. The Teensy 3.x support is based upon code in IRremote. The ESP32 support is based upon <a href="https://github.com/z3t0/Arduino-IRremote/pull/680">this pull request</a>.</p>
<p>The classes <code><a class="el" href="classIrWidget.html" title="Base class for classes based upon ICP pins capture.">IrWidget</a></code> and <code><a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget.">IrWidgetAggregating</a></code> are based on Michael's code. The classes <code><a class="el" href="classIrReceiverSampler.html" title="This receiving class samples the input pin every 50 microseconds using a timer interrupt.">IrReceiverSampler</a></code> and <code><a class="el" href="classIrSenderPwm.html" title="Sending function using timer PWM.">IrSenderPwm</a></code>, are adapted from Kevin's work. The remaining files are almost completely written from scratch.</p>
<p>This work is a low-level library (like <code>IRremote</code> and <code>IRLib</code>) that can be used in other projects, like <a href="https://github.com/bengtmartensson/AGirs">AGirs</a>, which is an high-level program taking commands interactively from a user or a program through a bi-directional <code>Stream</code>. The goal has been to provide a sound, object oriented basis for the fundamental basis, not to provide maximal functionality, the maximal number of protocols supported, or the most complete support of different hardware. A clean design and high readability, without being "too" inefficient, has been the highest priority. Dynamic memory allocation with <code>new</code> and <code>delete</code> is used extensively. The user who is afraid of this can create his required objects at the start of the run, and keep them. Most classes are immutable. The classes are <code>const</code>-correct.</p>
<h1>Comparison with other infrared libraries</h1>
<p>Here we list a (subjective!) selection of generic IR libraries for Arduino, with some (very personal) comments.</p>
<h2><a href="https://github.com/Arduino-IRremote/Arduino-IRremote">IRremote</a> by Ken Shirriff and others.</h2>
<p>The original, that spawned all the rest! Now hosted <a href="https://github.com/Arduino-IRremote/Arduino-IRremote/">here</a>. Was "stale" for several years, presently changes daily. License: MIT.</p>
<h2><a href="https://github.com/cyborg5/IRLib">IRlib version 1</a> and <a href="https://github.com/cyborg5/IRLib2">version 2</a> by Ken Shirriff and Chris Young.</h2>
<p>Subjectively, this is a cleaned-up and modernized version of IRremote. The basic structure is very similar, and it thus suffers from many of the basic problems of IRremote. It comes with a very ambitious PDF manual (125 pages!) entirely written by hand (not using a documentation system like Doxygen). It supports most 8 bit AVRs and SAMDs, but not ESPs. The libraries are not available in the Arduino library manager, however they are available on <a href="https://platformio.org/lib/show/1735/IRLib2">PlatformIO</a>. Licenses: LGPL2.1 (IRLib), GPL3 (IRLib2).</p>
<h2><a href="https://github.com/crankyoldgit/IRremoteESP8266">IRremoteESP8266</a> by David Conran, Ken Shirriff, and others.</h2>
<p>This library, as the name suggested, was created as a fork of IRremote, supporting ESP8266 and ESP32 only. Has evolved considerably since the fork new features, in particular, it also contains support for a large number of specialized protocols, like air conditioning protocols. License: LGPL2.1.</p>
<h2><a href="https://github.com/NicoHood/IRLremote">IRLremote</a> by Nico Hood.</h2>
<p>This "lightweight" library is written with the aim of minimal foot print on very small systems, like the ATTiny. License: MIT-like.</p>
<h1>Forum</h1>
<p>Feel free to open <a href="https://github.com/bengtmartensson/Infrared4Arduino/discussions">discussions</a> and <a href="https://github.com/bengtmartensson/Infrared4Arduino/issues">issues at Github</a> should the need or desire arise. Other possible place to discuss are the <a href="https://forum.arduino.cc/index.php?board=16.0">Home automation</a> or the <a href="https://forum.arduino.cc/index.php?board=10.0">Sensor</a> sub-forums at the Arduino forum.</p>
<h1>Examples</h1>
<p>A fairly large numbers of examples are provided. Most of these are a straight-forward demonstration of a particular class, as indicated by the name.</p>
<h1>API</h1>
<p>admin <a href="http://bengtmartensson.github.io/Infrared4Arduino">Up-to-date API, generated by Doxygen</a>.</p>
<h2>Types</h2>
<p>There are some project specific data typedefs in <code><a class="el" href="InfraredTypes_8h.html" title="This file defines some general data types that are used in the library.">InfraredTypes.h</a></code>. For durations in microseconds, the data type <code>microseconds_t</code> is to be used. If desired/necessary, this can be either <code>uint16_t</code> or <code>uint32_t</code>. For durations in milliseconds, use the type <code>millisecons_t</code>. Likewise, use <code>frequency_t</code> for modulation frequency in Hz (<em>not</em> kHz as in the IRremote/IRLib).</p>
<p>For "sizes", <code>size_t</code>, the standard C type, is used.</p>
<p>Implementation dependent types like <code>int</code> are used if and <em>only if</em> it is OK for the compiler to select any implementation allowed by the C++ language.</p>
<p><code>unsigned int</code> is used for quantities that can "impossibly" be larger than 65535. It is believed that (unsigned) int is the fastest type for doing arithmetics, containing 16 bits or more.</p>
<h2>IrSequences and IrSignals</h2>
<p>An <code><a class="el" href="classIrSequence.html" title="This class consists of a vector of durations.">IrSequence</a></code> is a vector of durations, i.e. sequence of interleaving on-periods (sometimes called <em>marks</em> or <em>flashes</em>) and off-periods (sometimes called <em>spaces</em> or <em>gaps</em>). It does not contain the modulation frequence. As opposed to IRremote and IRLib, our sequences always start with a on-period and end with an off-period. It is claimed to be a more relevant representation than the one of IRremote and IRLib.</p>
<p>An <code><a class="el" href="classIrSignal.html" title="This class models an IR signal with intro-, repeat-, and ending sequences.">IrSignal</a></code> consists of a modulation frequency and three <code><a class="el" href="classIrSequence.html" title="This class consists of a vector of durations.">IrSequence</a></code>s: intro-, repeat-, and ending sequence. All of these, but not all, can be empty. If repeat is empty, intro has to be non-empty and ending empty. The intro sequence is always sent first, then comes a zero or more repeat sequences, and finally the ending sequence. To send a signal <em>n</em> &gt; 0 times shall mean the following: If the intro is non-empty, send intro, <em>n</em> - 1 repeats, and then the ending. If the intro is empty, send <em>n</em> repeats, and then then ending.</p>
<h2>Signal data in flash memory.</h2>
<p>The examples <code>oppo_cooked</code> and <code>oppo_raw</code> consist of <a href="https://github.com/bengtmartensson/harctoolboxbundle">IrScrutinizer</a> exports of the infrared command set of the Oppo Bluray players, in parametrized and raw form respectively. The latter stores the raw signals in the flash area, "`PROGMEM`", (i.e. not taking up any (permanent) RAM storage) for which the API support is required. This is unfortunately not available with all architectures.</p>
<h2>Class construction</h2>
<p>For some receiving and transmitting classes, multiple instantiations are not sensible, for others, it may be. In this library, the classes that should only be instantiated once are implemented as singleton classes, i.e. with no public constructor, but instead a static "factory" method (<code>newThing()</code>) that delivers a pointer to a newly constructed instance of <code>Thing</code>, provided that <code>Thing</code> has not been instantiated before. The classes, where multiple instances is sensible, come with public constructors. (However, the user still has to take responsibility for avoiding pin- and timer-conflicts.)</p>
<h2>Hardware configuration</h2>
<p><a class="el" href="classBoard.html" title="This class serves as an HAL (Hardware Abstraction Layer).">Board</a> specific hardware configuration is located in the class <a class="el" href="classBoard.html" title="This class serves as an HAL (Hardware Abstraction Layer).">Board</a>, and in the board specific files in <code>src/boards</code>.</p>
<p>However, <a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget.">IrWidgetAggregating</a> is currently supported on the boards Uno/Nano (<a class="el" href="classATmega328P.html">ATmega328P</a>), Leonardo/Micro (<a class="el" href="classATmega32U4.html">ATmega32U4</a>), and Mega2560 (<a class="el" href="classATmega2560.html">ATmega2560</a>).</p>
<p>Several of the sending and receiving classes take a GPIO pin as argument to the constructor. However, the sending pin of <code><a class="el" href="classIrSenderPwm.html" title="Sending function using timer PWM.">IrSenderPwm</a></code> and the capture pin of <code><a class="el" href="classIrWidgetAggregating.html" title="This class implements the IrWidget.">IrWidgetAggregating</a></code> are not configurable, but (due to hardware limitations) have to be taken from the following table: </p><pre class="fragment">                                       Sender Pin      Capture Pin
Uno/Nano (ATmega328P)                       3             8
Leonardo/Micro (ATmega32U4)                 9             4
Mega2560 (ATmega2560)                       9            49
Due                                         7           n/a
Uno WiFi Rev2/Nano Every (ATmega4809)       6           n/a
Zero/M0 Pro/Nano Every IOT (ATSAMD21)       8           n/a
Teensy 3.x                                  5           n/a
ESP32                                       5           n/a
</pre><p> In some cases, this can be relatively easily changed in the code. A later version of the library may support more elaborate configuration.</p>
<p>The pin used by the the receivers (not to be confused with capture pins) can in general be selected freely, as long as it does not conflict with other requirements.</p>
<h3>ESP8266</h3>
<p>The ESP8266 is not a board very well suited for sending and receiving IR signals, since it lacks important features, as documented in <a href="https://github.com/bengtmartensson/Infrared4Arduino/issues/5#issuecomment-589957060">this issue</a>. Only the generic IR sender <a class="el" href="classIrSenderPwmSoftDelay.html" title="Sending function using timer PWM.">IrSenderPwmSoftDelay</a> and <a class="el" href="classIrSenderPwmSpinWait.html" title="This sender class generates the modulation in software, using spin wait.">IrSenderPwmSpinWait</a> as well as the generic IR receiver <a class="el" href="classIrReceiverPoll.html" title="An implementation of IrReceiver using polling of the input pin.">IrReceiverPoll</a> are available. For IR, please select another board if at all possible!</p>
<h2>Timeouts</h2>
<p>All the receiving classes adhere to the following conventions: When initialized, it waits up to the time <code>beginningTimeout</code> for the first on-period. If not received within that period, it returns with a timeout. Otherwise, is starts collecting data. It will collect data until one of the following occurs:</p><ul>
<li>A silence of length <code>endingTimeout</code> has been detected. This is the normal ending. The detected last gap is returned with the data.</li>
<li>The buffer gets full. Reception stops.</li>
</ul>
<h2>User parameters</h2>
<p>As opposed to other infrared libraries, there are no user changeable parameters as CPP symbols. However, the timer configuration is compiled in, depending on the CPP processors given to the compiler, see the file <code>IRremoteInt.h</code>.</p>
<h2>Files</h2>
<p>As opposed to the predecessor projects, this project has a header (<code>*.h</code>) file and an implementation file (<code>*.cpp</code>, sometimes missing) for each public class.</p>
<h2>Error handling</h2>
<p>Simple answer: there is none. If a function is sent erroneous data, it just silently ignores the request, or does something else instead. This (unfortunately) seems to be the standard procedure in Arduino programming.</p>
<p>I am used to exception based error handling, for some reason this is not used by the Arduino community.</p>
<p>Constructive suggestions are welcome.</p>
<h2>Protocols</h2>
<p>Comparing with the predecessor works, this project may look meager, currently supporting only two protocols (NEC1 and RC5). It is <a href="https://github.com/bengtmartensson/IrpTransmogrifier">planned</a> to generate the corresponding C++ code automatically from the IRP notation. (For this reason, contributed implementations of more protocols are not solicited.)</p>
<h2>Sending non-modulated signals.</h2>
<p>RF signals (433 MHz and other carrier frequencies) do not use the IR typical modulation. Also there are a few IR protocols (like <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=14186&amp;start=40">Revox, Barco, Archer</a>) not using modulation. These signals can be sent by the class <code><a class="el" href="classIrSenderNonMod.html" title="IrSender implementation without modulation, selectively with inverted output.">IrSenderNonMod</a></code>, after connecting suitable hardware capable of sending non-modulated (IR- <em>or</em> RF-) signals to the GPIO pin given as argument to the constructor.</p>
<h2>Hash codes</h2>
<p>Hash-based decoding is implemented in the class <a class="el" href="classHashDecoder.html" title="A decoder class using FNV-1 hashes of length 32.">HashDecoder</a>. For an example of use, see the example of LearningHashDecoder.</p>
<h2>Event driven reception</h2>
<p>IRLib and IRremoteESP8266 implements interrupt driven reception, but currently not this libary. It is <a href="https://github.com/bengtmartensson/Infrared4Arduino/issues/22">planned</a>.</p>
<h1>Blinking during receive.</h1>
<p>This library does not, as opposed to some of its competitors, implement blinking. I do not consider this to be a sensible method of debugging &ndash; using a logical analyzer together with Sigrok and Pulseview is a much better idea to do systematic debugging. Also for decoration and other "cool" light effects, there are better alternatives.</p>
<h2>Dependencies</h2>
<p>This library does not depend on any other libraries; only the standard Arduino environment.</p>
<h2>Questions and answers</h2>
<ul>
<li>What is the difference between the <code>IrReceiver*</code> and the <code>IrWidget*</code> classes?</li>
</ul>
<p>They are intended for two different use cases, <a href="http://www.harctoolbox.org/Glossary.html#ReceivingIrSignals">receiving</a> and <a href="http://www.harctoolbox.org/Glossary.html#Capturing">capturing</a>. Differently put, "receive" uses a demodulating receiver (TSOPxxx, etc.), "capture" a non-demodulating decoder (TSMPxxx, OPLxxx QSExxx, etc.). Note that this terminology is not universally accepted (yet!).</p>
<h1>Cooperation</h1>
<p>Your cooperation is solicited! Starting with testing, usage reports, bug reports and feedback (both code and documentation), over enhancements suggestions, to code and documentation contributions.</p>
<h1>Coding style</h1>
<p>My goal is to write excellent code, even though I do not always succeed :-). "Everything as simple as possible, but not simpler." Cleanliness, logical structure, readability and maintainability are the most important requirements. Efficiency (runtime and/or space) is also important, although it normally comes on second place. <a href="https://www.arduino.cc/en/Reference/APIStyleGuide">The Arduino Style Guide</a> has different goals (essentially optimizing for novice programmers, "Some of these run counter to professional programming practice"). It is therefore not given priority in this project.</p>
<h1>Documentation</h1>
<p>The main documentation for the classes is found in the source files themselves. It can be extracted to a browse-able documentation using the program <a href="http://www.doxygen.org">Doxygen</a>. After installing the program, fire up the program in the source directory. It will generate documentation in a subdirectory <code>html</code>. To browse, open <code>html/index.html</code> in a browser.</p>
<p>The documentation is written for the <em>user</em> of the library, not the developer. For this reason, the file <code>Arduino.h</code> has been deliberately excluded from the documentation, to keep it centered on the main issues for the programming on the target system.</p>
<h1>Multi platform coding</h1>
<p>For someone used to, e.g., Netbeans or Eclipse, the Arduino IDE feels "somewhat" primitive and limited. In particular, it does not support debugging. Mainly for this reason, the code in the present library is designed to compile, and at least to some extent, run in a normal C++ environment on the host compiler. For this, some code modifications, in particular, a customized <code>Arduino.h</code> was needed. If the preprocessor symbol <code>ARDUINO</code> is defined, just includes the standard Arduino <code>Arduino.h</code> is included, otherwise (i.e. for compiling for the host), some more-or-less dummy stuff are defined, allowing compiling for, and execution/debugging on the host.</p>
<p>This way, certain types of problems can be solved much faster. The drawback is that the code is "polluted" with ugly <code>#ifdef ARDUINO</code> statements, which decreases readability and makes maintenance harder.</p>
<p>The subdirectory <code>tests</code> contains test(s) that run on the host. The supplied <code>Makefile</code> is intended for compiling for the host as target. It creates a library in the standard sense (<code>*.a</code>), and can be used to build and run tests in subdirectory <code>tests</code>.</p>
<p>With the provided <code>Doxyfile</code>, Doxygen will document only the (strict) Arduino parts, not the "portable C++".</p>
<h1>License</h1>
<p>The entire work is licensed under the GPL2 "or later" license. Ken's code is licensed under the LGPL 2.1-license. Michael's code carries the GPL2-license, although he is <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=112586#112586">willing to agree to "or later versions"</a>. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 22 2021 17:58:06 for Infrared4Arduino by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
